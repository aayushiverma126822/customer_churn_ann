# -*- coding: utf-8 -*-
"""customer_churn_ann.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zAM-lijVQE8mG-hLVRsVmNS3Hat71UCs
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow as tf
from tensorflow import keras

df = pd.read_csv("customer_churn.csv")

df.describe()

df.info()

df.head()

df.dtypes

def showuq(df):
    for i in df:
        if df[i].dtype=='object':
            print('----------------------------------------')

            print(f'{i} : {df[i].unique()}')

df['tenure'].unique()

df.columns

df.isnull().sum()

df.drop(columns=['customerID'],axis=1,inplace= True)

df.head()

df['TotalCharges'].replace(" ","")

pd.to_numeric(df['TotalCharges'],errors='coerce').isnull()

df[pd.to_numeric(df['TotalCharges'],errors='coerce').isnull()]

df1 = df[df['TotalCharges']!=' ' ]

print(df.shape)
df1.shape

df1['TotalCharges']=df1['TotalCharges'].astype(float)

tenure_churn_yes = df[df['Churn']=='Yes']['tenure']
tenure_churn_no = df[df['Churn']=='No']['tenure']

plt.hist([tenure_churn_yes,tenure_churn_no],color=['Green','Red'],label=['Green=Yes','Red=No'])
plt.xlabel('Tenure')
plt.ylabel('Number of months')
plt.legend()

mc_churn_yes = df[df['Churn']=='Yes']['MonthlyCharges']
mc_churn_no = df[df['Churn']=='No']['MonthlyCharges']
plt.hist([mc_churn_yes,mc_churn_no],color=['Green','Red'],label=['Green=Yes','Red=No'])
plt.xlabel('Tenure')
plt.ylabel('Number of months')
plt.legend()

showuq(df1)

df1.replace('No internet service',"No",inplace=True)

df1.replace("No phone service",'No',inplace=True)

showuq(df1)

yes_no =['gender','Partner','Dependents','PhoneService','MultipleLines','OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies','Churn','PaperlessBilling']

for col in yes_no:
    df1[col].replace({'Yes':1,"No":0},inplace=True)

showuq(df1)

pd.get_dummies(data=df1,columns=['InternetService'])

df2=pd.get_dummies(data = df1 , columns=['InternetService','Contract','PaymentMethod'
])

df2

df2.replace(True,1,inplace=True)

df2.replace(False,0,inplace =True)

df2

df2.sample(4)

df2.dtypes

cols_to_scale = ['tenure','MonthlyCharges','TotalCharges']
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()

df2[cols_to_scale] = scaler.fit_transform(df2[cols_to_scale])

df2.replace

df2['gender'].replace({"Male":1,"Female":0},inplace=True)

df2

df2.columns

for col in df2:
    print(f'{col},{df2[col].unique()}')

X = df2.drop('Churn',axis=1)
y = df2['Churn']

from sklearn.model_selection import train_test_split
X_train, X_test , y_train , y_test = train_test_split(X,y,test_size=0.2,random_state=42)

X_train.shape

y_train

import tensorflow as tf
from tensorflow import keras

model = keras.Sequential([
    keras.layers.Dense(20,input_shape = (26,),activation='relu'),
    keras.layers.Dense(15,activation='tanh'),
    keras.layers.Dense(1,activation='sigmoid')

])

model.compile(optimizer='adam',
              loss = 'binary_crossentropy',
              metrics=['accuracy'])

model.fit(X_train,y_train,epochs = 50)

model.evaluate(X_test,y_test)

yp = model.predict(X_test)

y_test[:10]

yp[:10]

ypn =[]
for i in yp:
    if i >0.50:
        ypn.append(1)
    else:
        ypn.append(0)

ypn[:10]

y_test[:10]

from sklearn.metrics import classification_report
print(classification_report(y_test,ypn))

import seaborn as sns
cm = tf.math.confusion_matrix(labels=y_test,predictions=ypn)
plt.figure(figsize=(10,7))
sns.heatmap(cm,annot = True,fmt ='d')
plt.xlabel('Predicted')
plt.ylabel('Truth')

recall = (904)/(904+129)

round(recall,2)

accuracy = (904+191)/(904+191+129+183)

print(round(accuracy,2))

precision = (904)/(904+183)

round(precision,2)

"""## Handling Imbalance Dataset

"""

def ANN(X_train,X_test,y_train,y_test,loss,weights):
    model = keras.Sequential([
        keras.layers.Dense(26,input_dim=26,activation='relu'),
        keras.layers.Dense(15,activation='relu'),
        keras.layers.Dense(1,activation='sigmoid')
    ])
    model.compile(optimizer='adam',loss=loss,metrics=['accuracy'])

    if weights ==-1:
        model.fit(X_train,y_train,epochs=100)
    else:
        model.fit(X_train,y_train,epochs=100,class_weight=weights)

    print(model.evaluate(X_test,y_test))

    y_preds = model.predict(X_test)
    y_preds= np.round(y_preds)

    print("classification_report: \n: ",classification_report(y_test,y_preds))

    return y_preds

y_preds = ANN(X_train,X_test,y_train,y_test,'binary_crossentropy',-1)

print(classification_report(y_test,y_preds))

y_test.value_counts()

count_class_0 , count_class_1 = df1.Churn.value_counts()

df_class_0 = df2[df2['Churn']==0]
df_class_1 = df2[df2['Churn']==1]

df_class_0.shape

df_class_1.shape

df_class_0_under = df_class_0.sample(count_class_1)

df_test_under= pd.concat([df_class_0_under ,df_class_1,],axis = 0 )
df_test_under.shape

X=df_test_under.drop(columns=['Churn'],axis=1)
y = df_test_under['Churn']
X_train, X_test , y_train , y_test = train_test_split(X,y,test_size=0.2,random_state=42,stratify=y)

y_train.value_counts()

y_test.value_counts()

y_preds = ANN(X_train,X_test,y_train,y_test,'binary_crossentropy',-1)
print(classification_report(y_test,y_preds))

"""### Over sampling"""

count_class_0,count_class_1

df_class_1_over=df_class_1.sample(count_class_0,replace=True)

df_class_1_over.shape

df_test_over=pd.concat([df_class_0,df_class_1_over],axis=0)

df_test_over.shape

df_test_over.Churn.value_counts()

class Annmodel():
    def __init__(self,df):
        X=df.drop(columns=['Churn'],axis=1)
        y = df['Churn']
        X_train, X_test , y_train , y_test = train_test_split(X,y,test_size=0.2,random_state=42,stratify=y)
        self.X_train=X_train
        self.X_test=X_test
        self.y_train=y_train
        self.y_test= y_test


    def ANN(self,loss,weights):
        model = keras.Sequential([
            keras.layers.Dense(26,input_dim=26,activation='relu'),
            keras.layers.Dense(15,activation='relu'),
            keras.layers.Dense(1,activation='sigmoid')
        ])
        model.compile(optimizer='adam',loss=loss,metrics=['accuracy'])

        if weights ==-1:
            model.fit(self.X_train,self.y_train,epochs=100)
        else:
            model.fit(self.X_train,self.y_train,epochs=100,class_weight=weights)

        print(model.evaluate(self.X_test,self.y_test))

        y_preds = model.predict(X_test)
        y_preds= np.round(y_preds)

        print("classification_report: \n: ",classification_report(y_test,y_preds))

        return y_preds

oversample=Annmodel(df_test_over)

print(oversample.y_test.value_counts())
print(oversample.y_train.value_counts())

y_preds = oversample.ANN('binary_crossentropy',-1)

"""## SMOTE"""

X = df2.drop('Churn',axis = 'columns')
y = df2['Churn']

from imblearn.over_sampling import SMOTE

X.shape,y.shape

y.value_counts()

X.head()

y.head()

from imblearn.over_sampling import SMOTE

smote = SMOTE(sampling_strategy='minority')
X_sm, y_sm = smote.fit_resample(X, y)

print(X_sm.shape,y_sm.shape)

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test = train_test_split(X_sm,y_sm,stratify=y_sm,random_state=42,test_size=0.2)

y_train.value_counts()

y_test.value_counts()

print(X_train.shape,y_train.shape,X_test.shape,y_test.shape)

y_preds = ANN(X_train,X_test,y_train,y_test,'binary_crossentropy',-1)

